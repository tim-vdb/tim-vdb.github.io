import*as THREE from"https://cdn.jsdelivr.net/npm/three@0.156.0/build/three.module.js";console.log(THREE,"THREE");import{GLTFLoader}from"https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/loaders/GLTFLoader.js";console.log(GLTFLoader,"GLTFLoader");import{OrbitControls}from"https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/controls/OrbitControls.js";console.log(OrbitControls,"OrbitControls");import{EffectComposer}from"https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/postprocessing/EffectComposer.js";console.log(EffectComposer,"EffectComposer");import{RenderPass}from"https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/postprocessing/RenderPass.js";console.log(RenderPass,"RenderPass");import{UnrealBloomPass}from"https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/postprocessing/UnrealBloomPass.js";console.log(UnrealBloomPass,"UnrealBloomPass");import{ShaderPass}from"https://cdn.jsdelivr.net/npm/three@0.156.0/examples/jsm/postprocessing/ShaderPass.js";console.log(ShaderPass,"ShaderPass");const KirschShader={uniforms:{tDiffuse:{value:null},resolution:{value:new THREE.Vector2}},vertexShader:"\n        varying vec2 vUv;\n        void main() {\n            vUv = uv;\n            gl_Position = projectionMatrix * modelViewMatrix * vec4(position, 1.0);\n        }\n    ",fragmentShader:"\n        varying vec2 vUv;\n        uniform sampler2D tDiffuse;\n        uniform vec2 resolution;\n\n        mat3 kirschKernelX = mat3(\n            5.0,  5.0,  5.0,\n            -3.0,  0.0, -3.0,\n            -3.0, -3.0, -3.0\n        );\n\n        mat3 kirschKernelY = mat3(\n            5.0, -3.0, -3.0,\n            5.0,  0.0, -3.0,\n            5.0, -3.0, -3.0\n        );\n\n        float applyKirsch(mat3 kernel, vec2 uv, vec2 texelSize) {\n            float edge = 0.0;\n            for (int i = -1; i <= 1; i++) {\n                for (int j = -1; j <= 1; j++) {\n                    vec2 offset = texelSize * vec2(float(i), float(j));\n                    vec4 color = texture2D(tDiffuse, uv + offset);\n                    edge += kernel[i + 1][j + 1] * color.r;\n                }\n            }\n            return edge;\n        }\n\n        void main() {\n            vec2 texelSize = 0.2 / resolution;\n            float edgeX = applyKirsch(kirschKernelX, vUv, texelSize);\n            float edgeY = applyKirsch(kirschKernelY, vUv, texelSize);\n            float edge = sqrt(edgeX * edgeX + edgeY * edgeY);\n\n            vec4 originalColor = texture2D(tDiffuse, vUv);\n            vec3 edgeColor = vec3(1.0, 0.5, 0.0);\n            float intensity = clamp(edge, 0.0, 0.4);\n\n            vec3 finalColor = mix(originalColor.rgb, edgeColor, intensity);\n            finalColor *= (0.2 + intensity);\n            finalColor += edgeColor * intensity * 0.5;\n            \n            gl_FragColor = vec4(finalColor, originalColor.a);\n        }\n    "},canvas=document.getElementById("canvas"),scene=new THREE.Scene,camera=new THREE.PerspectiveCamera(75,window.innerWidth/window.innerHeight,.1,100),renderer=new THREE.WebGLRenderer({canvas:canvas,antialias:!0});renderer.setClearColor(1842204,1),renderer.setSize(window.innerWidth,window.innerHeight),document.body.appendChild(renderer.domElement),camera.position.set(0,0,9);const renderScene=new RenderPass(scene,camera),bloomPass=new UnrealBloomPass(new THREE.Vector2(window.innerWidth,window.innerHeight),.6,1,0),kirschPass=new ShaderPass(KirschShader);kirschPass.uniforms.resolution.value.set(window.innerWidth,window.innerHeight);const composer=new EffectComposer(renderer);composer.addPass(renderScene),composer.addPass(bloomPass),composer.addPass(kirschPass);const loader=new GLTFLoader,animationDelay=300;let mixer;loader.load("./public/Code3D.glb",(function(gltf){const mesh=gltf.scene;mesh.rotation.y=-Math.PI/2,mesh.position.set(-.2,0,0),scene.add(mesh),gltf.animations.length||console.warn("Le modÃ¨le GLTF ne contient aucune animation."),gltf.animations&&gltf.animations.length&&(mixer=new THREE.AnimationMixer(mesh),gltf.animations.forEach((clip=>{const action=mixer.clipAction(clip);setTimeout((()=>{action.timeScale=4,action.play()}),300)})))}),void 0,(function(error){console.error(error)}));const light=new THREE.PointLight(16777215,1,100);light.position.set(10,10,10),scene.add(light);let lastFrameTime=0;const frameInterval=1e3/30;function resizeCanvas(){window.devicePixelRatio;canvas.width=window.innerWidth,canvas.height=window.innerHeight,renderer.setSize(canvas.width,canvas.height,!1),composer.setSize(canvas.width,canvas.height),renderer.domElement.style.width=`${window.innerWidth}px`,renderer.domElement.style.height=`${window.innerHeight}px`,camera.aspect=window.innerWidth/window.innerHeight,camera.updateProjectionMatrix(),canvas.width<1024?(camera.fov=75,camera.position.set(-.25,0,15)):camera.position.set(0,0,9)}function animate(time){requestAnimationFrame(animate),time-lastFrameTime<frameInterval||(lastFrameTime=time,mixer&&mixer.update(.01),composer.render())}resizeCanvas(),window.addEventListener("resize",resizeCanvas),animate();